import collections
import functools
import typing

from .exceptions import NoResult


T = typing.TypeVar('T')


class Action:
    pass


class DataAction(Action):
    def __init__(self, data: bytes) -> None:
        self.data = data


class SendAction(DataAction):
    pass


class PutBackAction(DataAction):
    pass


class ReadAction(Action):
    pass


class YieldAction(Action):
    pass


ProtocolGenerator = typing.Generator[Action, typing.Optional[bytes], T]


class Result(typing.Generic[T]):
    def __init__(self):
        # This is a nice trick to please the type hinter. Optional[None] is not
        # possible in Python. When people want to do that (without the type hinting)
        # the use a sentinel object ('missing = object()') but this is super hard to
        # type hint. This neat trick guarantees the that the type is valid.
        self._value = []  # type: typing.List[T]

    @property
    def is_set(self):
        assert len(self._value) <= 1, "Should not have more than one value"
        return len(self._value) == 1

    def set(self, value: T):
        if self.is_set:  # pragma: no cover
            raise RuntimeError("Can't set the result twice")
        self._value.append(value)

    def get_value(self):
        if not self.is_set:
            raise NoResult
        assert len(self._value) == 1
        return self._value[0]


def send(data: bytes) -> ProtocolGenerator[None]:
    ret = yield SendAction(data)
    assert ret is None, "The protocol should not send anything back"


def read() -> ProtocolGenerator[bytes]:
    data = yield ReadAction()
    assert isinstance(data, bytes), "The protocol should return bytes"
    return data


def putback(data: bytes) -> ProtocolGenerator[None]:
    ret = yield PutBackAction(data)
    assert ret is None, "The protocol should not send anything back"


class Protocol(typing.Generic[T]):
    def __init__(self, generator: ProtocolGenerator[T]) -> None:
        self._generator = generator
        self._input = collections.deque()  # type: typing.Deque[bytes]
        self._output = collections.deque()  # type: typing.Deque[bytes]
        self._current_action = None  # type: typing.Optional[Action]
        self._result = Result()  # type: Result[T]

    def send(self, data: bytes) -> None:
        """Send bytes to the coroutine to consume"""

        self._input.append(data)
        self._process()

    def read(self) -> bytes:
        """Read bytes generated by the coroutine."""
        self._process()
        data = b''.join(self._output)
        self._output = collections.deque()
        return data

    def close(self) -> None:
        raise NotImplementedError  # TODO

    @property
    def has_result(self):
        try:
            self.get_result()
            return True
        except NoResult:
            return False

    def get_result(self) -> T:
        """Get the result from the coroutine.

        Returns:
            The result from the coroutine.

        Raises:
            NoResult: if the coroutine hasn't returned yet.
        """
        self._process()
        return self._result.get_value()

    def _process(self) -> None:
        if self._result.is_set:
            return

        try:
            while True:
                if self._current_action is None:
                    self._current_action = next(self._generator)

                if isinstance(self._current_action, SendAction):
                    self._output.append(self._current_action.data)
                    self._current_action = None
                elif isinstance(self._current_action, ReadAction):
                    if not self._input:
                        break
                    data = b''.join(self._input)
                    self._input = collections.deque()
                    self._current_action = self._generator.send(data)
                elif isinstance(self._current_action, PutBackAction):
                    self._input.appendleft(self._current_action.data)
                    self._current_action = None
                else:  # pragma: no cover
                    raise RuntimeError("Unavailable action {!r}".format(self._current_action))
        except StopIteration as res:  # on next() and _generator.send()
            self._result.set(res.value)

def protocol(f: typing.Callable[..., ProtocolGenerator[T]]) -> typing.Callable[..., Protocol[T]]:
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        return Protocol(f(*args, **kwargs))
    return wrapper
